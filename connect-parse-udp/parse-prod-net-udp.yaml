input:
  generate:
    interval: 2s
    mapping: |
      root = file("/proc/net/udp")

pipeline:
  processors:
    - bloblang: |
        # Split the content into lines
        root = this.split("\n")

        # Filter out empty lines and the header
        root = root.filter(line -> line.length() > 0 && !line.contains("local_address"))

        # Parse each UDP connection line
        root = root.map_each(line -> {
          "raw_line": line,
          "fields": line.split_regex("\\s+").filter(f -> f.length() > 0),
        })

        # Extract meaningful fields from each connection
        root = root.map_each(entry -> {
          let queue_parts = entry.fields.index(4).split(":")
          let tm_when_parts = entry.fields.index(5).split(":")
          let local_parts = entry.fields.index(1).split(":")
          let remote_parts = entry.fields.index(2).split(":")
          "sl": entry.fields.index(0),
          "local_address": local_parts.index(0),
          "local_port_hex": local_parts.index(1),
          "local_port": local_parts.index(1).parse_int(16),
          "remote_address": remote_parts.index(0),
          "remote_port_hex": remote_parts.index(1),
          "remote_port": remote_parts.index(1).parse_int(16),
          "state": entry.fields.index(3),
          "tx_queue": queue_parts.index(0),
          "rx_queue": queue_parts.index(1),
          "tr": tm_when_parts.index(0),
          "tm_when": tm_when_parts.index(1),
          "retrnsmt": entry.fields.index(6),
          "uid": entry.fields.index(7),
          "timeout": entry.fields.index(8),
          "inode": entry.fields.index(9),
          "ref": entry.fields.index(10),
          "pointer": entry.fields.index(11),
          "drops": entry.fields.index(12),
          "timestamp": now(),
          "raw_line": entry.raw_line
        })

    - metric:
        type: gauge
        name: udp_rx_queue_bytes
        labels:
          local_port: ${! this.local_port }
          inode: ${! this.inode }
        value: ${! this.rx_queue.parse_int(16) }

    - metric:
        type: counter
        name: udp_drops_total
        labels:
          local_port: ${! this.local_port }
          inode: ${! this.inode }
        value: ${! this.drops.number() }

metrics:
  prometheus:
    prefix: redpanda_connect

output:
  stdout:
    codec: lines
